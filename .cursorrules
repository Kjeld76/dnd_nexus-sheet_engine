# D&D Nexus Cursor Rules

## Project Context
Windows Desktop D&D 5e 2024 Charakterbogen-Generator mit Tauri 2.0, React 19, Rust, SQLite.

## Tech Stack
- Frontend: React 19 + TypeScript 5.6 + Vite + Tailwind CSS
- Backend: Rust + Tauri 2.0
- Database: SQLite (rusqlite)
- State: Zustand
- Icons: Lucide React

## Project Structure
```
dnd-nexus/
├── src/                    # React Frontend
│   ├── components/
│   ├── screens/
│   ├── lib/
│   │   ├── api.ts
│   │   ├── types.ts
│   │   └── store.ts
│   └── main.tsx
├── src-tauri/              # Rust Backend
│   ├── src/
│   │   ├── main.rs
│   │   ├── commands/
│   │   ├── db/
│   │   └── core/
│   └── Cargo.toml
└── tools/                  # PDF Parser
```

## Coding Standards

### TypeScript
- Use strict mode
- Explicit return types for functions
- Interfaces over types
- Named exports (no default exports except components)
- Functional components with hooks
- No console.log in production code

### Rust
- Use `rustfmt` formatting
- Explicit error handling (Result<T, String>)
- No unwrap() in production, use ? operator
- Document public functions
- Use serde for serialization
- Prefer String over &str for Tauri commands

### React Components
- Functional components only
- Props interface always defined
- Use React.FC type sparingly (prefer explicit typing)
- Hooks at top of component
- Extract complex logic to custom hooks
- Tailwind for styling (no inline styles)

### File Naming
- React components: PascalCase.tsx
- Utilities: camelCase.ts
- Rust modules: snake_case.rs
- Constants: SCREAMING_SNAKE_CASE

## Database Rules
- All timestamps as INTEGER (unixepoch())
- JSON columns for complex data
- Always use prepared statements
- Core tables READ-ONLY in UI
- Custom tables for user edits
- Use views for combining core + custom

## Tauri Commands
- Always async
- Return Result<T, String>
- Use State<'_, Database> for DB access
- Serialize with serde_json
- Document with /// comments
- One command per operation (no multi-purpose commands)

## D&D 5e 2024 Rules
- Attribute modifier: (score - 10) / 2
- Proficiency bonus: Level 1-4: +2, 5-8: +3, 9-12: +4, 13-16: +5, 17-20: +6
- Expertise: 2× Proficiency Bonus
- Carrying Capacity: STR × 15 lbs
- Metric conversion: ft × 0.3 = m, lbs × 0.4535 = kg

## State Management
- Zustand for global state
- No Redux
- Local state for UI-only data
- Derive computed values (don't store)

## Error Handling
- Frontend: try-catch with user-friendly messages
- Backend: Result<T, String> always
- Log errors to console in dev
- Show toast notifications for user errors

## Performance
- Virtual lists for 100+ items (use @tanstack/react-virtual)
- Memoize expensive calculations
- Debounce user input (300ms)
- Lazy load heavy components
- SQLite indexes on frequently queried columns

## Security
- No eval() or dangerouslySetInnerHTML
- Validate all user input
- Use Tauri's IPC (no direct window exposure)
- SQLite prepared statements only

## Git Commit Format
```
type(scope): subject

body
```
Types: feat, fix, docs, style, refactor, test, chore

## Testing
- Unit tests for core logic
- Integration tests for Tauri commands
- E2E tests for critical flows
- Minimum 80% coverage for business logic

## Dependencies
Never install packages not in this list:
### Frontend
- react, react-dom
- zustand
- @tauri-apps/api
- lucide-react
- @tanstack/react-virtual
- clsx, tailwind-merge

### Backend (Cargo.toml)
- tauri 2.0
- serde, serde_json
- rusqlite (bundled feature)
- uuid (v4, serde features)

### Tools
- pdf-parse
- mammoth
- ajv

## Prohibited
- No localStorage/sessionStorage
- No axios (use fetch)
- No lodash (use native JS)
- No moment.js (use native Date)
- No jQuery
- No class components
- No any type
- No @ts-ignore
- No console.log in main branch

## Character Data Model
```typescript
interface Character {
  id: string;
  meta: {
    name: string;
    level: number;
    useMetric: boolean;
  };
  progression: {
    classes: Array;
  };
  attributes: {
    str: number;
    dex: number;
    con: number;
    int: number;
    wis: number;
    cha: number;
  };
  modifiers: Modifier[];
}

interface Modifier {
  id: string;
  source: string;
  target: string;
  type: 'override' | 'add' | 'multiply';
  value: number;
  condition?: string;
}
```

## Tauri Command Pattern
```rust
#[tauri::command]
pub async fn command_name(
    db: State,
    param: Type,
) -> Result {
    let conn = db.0.lock().unwrap();
    // implementation
    Ok(result)
}
```

## React Component Pattern
```tsx
interface Props {
  prop: Type;
  onAction: (value: Type) => void;
}

export function ComponentName({ prop, onAction }: Props) {
  const [state, setState] = useState();
  
  useEffect(() => {
    // side effects
  }, [dependencies]);
  
  return (
    
      {/* JSX */}
    
  );
}
```

## API Call Pattern
```typescript
// src/lib/api.ts
import { invoke } from '@tauri-apps/api/tauri';

export const api = {
  async operation(param: Type): Promise {
    return await invoke('command_name', { param });
  },
};
```

## SQL Query Pattern
```sql
-- Core table
CREATE TABLE core_entity (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  data TEXT NOT NULL,
  created_at INTEGER DEFAULT (unixepoch())
);

-- Custom table
CREATE TABLE custom_entity (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  data TEXT NOT NULL,
  parent_id TEXT,
  is_homebrew BOOLEAN DEFAULT 1,
  FOREIGN KEY (parent_id) REFERENCES core_entity(id)
);

-- Combined view
CREATE VIEW all_entities AS
SELECT COALESCE(c.id, core.id) as id,
       COALESCE(c.name, core.name) as name,
       CASE 
         WHEN c.parent_id IS NOT NULL THEN 'override'
         WHEN c.is_homebrew = 1 THEN 'homebrew'
         ELSE 'core'
       END as source
FROM core_entity core
LEFT JOIN custom_entity c ON c.parent_id = core.id
UNION
SELECT id, name, 'homebrew' as source
FROM custom_entity
WHERE parent_id IS NULL;
```

## Build Commands
```bash
# Development
pnpm tauri dev

# Production
pnpm tauri build

# Tests
cargo test
pnpm test

# Format
cargo fmt
pnpm format

# Lint
cargo clippy
pnpm lint
```

## Ruleset Priority
1. Security > Performance > Developer Experience
2. Type safety is mandatory
3. No runtime errors acceptable
4. User experience > Code elegance
5. Offline-first always

